<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Go Quant Assignment: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Go Quant Assignment
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This documentation is part of the bonus section for the project, detailing the optimization techniques implemented to improve CPU performance and reduce latency in high-frequency trading systems.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Memory Management</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Implemented Techniques</h2>
<h3><a class="anchor" id="autotoc_md3"></a>
1. Smart Pointers</h3>
<ul>
<li>The project uses <code>std::unique_ptr</code> and <code>std::shared_ptr</code> to manage dynamic memory safely.</li>
<li>For example, the WebSocket stream (<code>ws</code>) in <code><a class="el" href="classDeriClient.html" title="Client for connecting to Deribit&#39;s WebSocket API.">DeriClient</a></code> is managed using a <code>std::unique_ptr</code>, ensuring proper cleanup when the object goes out of scope:</li>
</ul>
<div class="fragment"><div class="line">std::unique_ptr&lt;websocket::stream&lt;ssl::streambeast::tcp_stream&gt;&gt; ws;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md4"></a>
2. Object Pooling</h3>
<ul>
<li>Implemented a <code><a class="el" href="classBufferPool.html" title="A thread-safe pool for managing reusable buffers.">BufferPool</a></code> class to reuse WebSocket buffers, reducing allocation overhead</li>
<li>This optimization significantly reduces memory allocation/deallocation costs in high-frequency operations.</li>
</ul>
<h3><a class="anchor" id="autotoc_md5"></a>
3. Efficient Queuing</h3>
<ul>
<li>The project uses <code>moodycamel::ConcurrentQueue</code> for lock-free message queuing, reducing memory contention and improving performance.</li>
</ul>
<h3><a class="anchor" id="autotoc_md6"></a>
4. Avoiding Unnecessary Copies</h3>
<ul>
<li>The use of <code>std::move</code> ensures efficient transfer of ownership without copying data unnecessarily.</li>
<li>Lambda captures with <code>shared_from_this()</code> ensure proper object lifetime management.</li>
</ul>
<h3><a class="anchor" id="autotoc_md7"></a>
5. Buffer Reuse and preallocation</h3>
<ul>
<li>Shared pointers for the buffer are preallocated during instantiation of the class.</li>
<li>Shared pointers are used for buffers in asynchronous operations to avoid repeated allocations.</li>
<li>Buffers are properly cleared before being returned to the pool.</li>
</ul>
<h1><a class="anchor" id="autotoc_md8"></a>
Network Communication</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
Implemented Techniques</h2>
<h3><a class="anchor" id="autotoc_md10"></a>
1. Asynchronous I/O</h3>
<ul>
<li>The project uses Boost.Asio for non-blocking, asynchronous I/O operations, ensuring efficient network communication without blocking threads.</li>
</ul>
<p><b>Justification for Asynchronous I/O in Trading Systems:</b></p>
<p><b>High Concurrency:</b></p>
<ul>
<li>Trading systems often need to handle hundreds or thousands of simultaneous WebSocket connections for market data updates and order execution. Async I/O enables this level of concurrency efficiently.</li>
</ul>
<p><b>Low Latency Requirements:</b></p>
<ul>
<li>In trading systems, every microsecond counts. Async I/O minimizes latency by allowing multiple operations to execute concurrently without blocking.</li>
</ul>
<p><b>Scalability:</b></p>
<ul>
<li>Async I/O scales well with increasing numbers of connections, making it ideal for high-frequency trading platforms.</li>
</ul>
<p><b>Efficient Resource Usage:</b></p>
<ul>
<li>Async I/O reduces resource consumption by eliminating the need for one thread per connection.</li>
<li>Example: Asynchronous read and write operations in <code><a class="el" href="classDeriClient.html" title="Client for connecting to Deribit&#39;s WebSocket API.">DeriClient</a></code>:</li>
</ul>
<h3><a class="anchor" id="autotoc_md11"></a>
2. TCP_NODELAY</h3>
<ul>
<li>TCP_NODELAY is enabled to reduce latency by disabling Nagle's algorithm, ensuring that small packets are sent immediately instead of waiting for more data.</li>
<li>Example: Enabling TCP_NODELAY in <code><a class="el" href="classDeriClient.html" title="Client for connecting to Deribit&#39;s WebSocket API.">DeriClient</a></code>:</li>
</ul>
<h3><a class="anchor" id="autotoc_md12"></a>
3. WebSocket Configuration</h3>
<ul>
<li>WebSocket-specific optimizations are applied to reduce write delay and improve throughput:</li>
<li>Auto-fragmentation is disabled (<code>ws_.auto_fragment(false)</code>).</li>
<li>Write buffer size is set (<code>ws_.write_buffer_bytes(4096)</code>).</li>
<li>Example: WebSocket session configuration:</li>
</ul>
<h3><a class="anchor" id="autotoc_md13"></a>
4. Message Queuing</h3>
<ul>
<li>The project uses <code>moodycamel::ConcurrentQueue</code> for lock-free queuing of outgoing messages, ensuring efficient handling of multiple write operations.</li>
<li>Example: Adding messages to the queue and triggering writes:</li>
</ul>
<h1><a class="anchor" id="autotoc_md14"></a>
Data Structure Selection</h1>
<h2><a class="anchor" id="autotoc_md15"></a>
Implemented Techniques</h2>
<h3><a class="anchor" id="autotoc_md16"></a>
1. Ordered Maps for Order Books</h3>
<ul>
<li>The project uses <code>std::map</code> to represent order books, where bids and asks are stored as price â†’ size mappings.</li>
<li>Bids are sorted in descending order (<code>std::greater&lt;double&gt;</code>), while asks are sorted in ascending order (<code>std::less&lt;double&gt;</code>).</li>
<li>This ensures efficient retrieval of the best bid and ask prices during trading operations.</li>
</ul>
<h3><a class="anchor" id="autotoc_md17"></a>
2. Unordered Maps for Fast Lookups</h3>
<ul>
<li><code>std::unordered_map</code> is used for storing and retrieving order books by symbol and request methods by ID.</li>
<li>Provides average O(1) time complexity for lookups, which is critical for high-frequency trading systems.</li>
</ul>
<h3><a class="anchor" id="autotoc_md18"></a>
3. Concurrent Queues for Thread-Safe Operations</h3>
<ul>
<li><code>moodycamel::ConcurrentQueue</code> is used for lock-free queuing of outgoing WebSocket messages.</li>
<li>Ensures thread-safe access without the overhead of mutexes or locks.</li>
</ul>
<h3><a class="anchor" id="autotoc_md19"></a>
4. Sets for Subscriber Management</h3>
<ul>
<li><code>std::set</code> is used to track subscribers for each trading symbol. This ensures efficient insertion, deletion, and lookup operations.</li>
</ul>
<h3><a class="anchor" id="autotoc_md20"></a>
5. Flat Buffers for Efficient Message Handling</h3>
<ul>
<li><code>boost::beast::flat_buffer</code> is used to store incoming WebSocket messages.</li>
<li>Provides a compact and efficient buffer representation suitable for high-frequency message handling.</li>
</ul>
<h1><a class="anchor" id="autotoc_md21"></a>
Thread Management</h1>
<h2><a class="anchor" id="autotoc_md22"></a>
Implemented Techniques</h2>
<h3><a class="anchor" id="autotoc_md23"></a>
1. Asynchronous I/O Eliminates Thread Management</h3>
<ul>
<li>The project uses Boost.Asio's asynchronous I/O model, which eliminates the need for explicit thread management.</li>
<li>All operations (e.g., WebSocket reads, writes, and timers) are handled via callbacks, ensuring non-blocking execution without requiring dedicated threads for each connection.</li>
</ul>
<h1><a class="anchor" id="autotoc_md24"></a>
CPU Optimization</h1>
<h2><a class="anchor" id="autotoc_md25"></a>
Implemented Techniques</h2>
<h3><a class="anchor" id="autotoc_md26"></a>
1. SIMD-Optimized JSON Parsing</h3>
<ul>
<li>The project uses <code>simdjson</code> for parsing JSON responses from the Deribit API.</li>
<li><code>simdjson</code> leverages SIMD (Single Instruction, Multiple Data) instructions to process multiple bytes of JSON data simultaneously, significantly improving performance compared to traditional parsers.</li>
</ul>
<h3><a class="anchor" id="autotoc_md27"></a>
2. Compiler Optimization Flags</h3>
<ul>
<li>The project is compiled with aggressive optimization flags (<code>-O3</code>) to enable features like inlining, vectorization, and loop unrolling.</li>
</ul>
<h3><a class="anchor" id="autotoc_md28"></a>
3. CPU Frequency Scaling</h3>
<ul>
<li>Disable dynamic CPU frequency scaling (e.g., Intel SpeedStep) to prevent latency spikes caused by frequency changes. Locking the CPU frequency at its maximum performance level makes sure consistent and predictable processing times.</li>
</ul>
<h3><a class="anchor" id="autotoc_md29"></a>
4. Use of Huge Pages</h3>
<ul>
<li>Huge pages reduce the overhead of memory management by using larger page sizes. This can reduce TLB (Translation Lookaside Buffer) misses and improve memory access performance.</li>
</ul>
<h1><a class="anchor" id="autotoc_md30"></a>
Detailed Analysis of Bottlenecks Identified</h1>
<h3><a class="anchor" id="autotoc_md31"></a>
Bottleneck 1: WebSocket Message Propagation</h3>
<ul>
<li><b>Observation</b>: The WebSocket propagation latency statistics show:<ul>
<li>Average latency: <b>0.35 ms</b></li>
<li>95th percentile: <b>0.41 ms</b></li>
<li>99th percentile: <b>0.79 ms</b></li>
</ul>
</li>
<li><b>Cause</b>: Latency spikes in the 99th percentile indicate occasional delays, likely due to message queuing or network-related overhead.</li>
</ul>
<h3><a class="anchor" id="autotoc_md32"></a>
Bottleneck 2: Order Placement Latency</h3>
<ul>
<li><b>Observation</b>: The order placement latency statistics show:<ul>
<li>Average latency: <b>170.4 ms</b></li>
<li>Max latency: <b>181.3 ms</b></li>
</ul>
</li>
<li><b>Cause</b>: High latencies are caused by network round-trip times (the ping to Deribit was showing <b>170 - 171 ms</b>) and the processing time required by the Deribit API.</li>
</ul>
<h3><a class="anchor" id="autotoc_md33"></a>
Bottleneck 3: Market Data Processing</h3>
<ul>
<li><b>Observation</b>: The market data processing statistics show:<ul>
<li>Average processing time: <b>8.58 Âµs</b></li>
<li>Max processing time: <b>97.87 Âµs</b></li>
</ul>
</li>
<li><b>Cause</b>: Occasional spikes in processing time are likely due to JSON parsing or order book updates, especially when the initial snapshot is received, it is larger in size thus may lead to spikes.</li>
</ul>
<h1><a class="anchor" id="autotoc_md34"></a>
Benchmarking and Performance Analysis</h1>
<h2><a class="anchor" id="autotoc_md35"></a>
1. Benchmarking Methodology</h2>
<h3><a class="anchor" id="autotoc_md36"></a>
Tools Used</h3>
<ul>
<li><b>High-resolution timers</b> (<code>std::chrono::high_resolution_clock</code>) were used to measure latencies at nanosecond precision.</li>
<li>Performance metrics were collected for:<ul>
<li>WebSocket message propagation latency</li>
<li>Order placement latency</li>
<li>Market data processing latency</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md37"></a>
Steps Taken</h3>
<h4><a class="anchor" id="autotoc_md38"></a>
WebSocket Propagation Latency:</h4>
<ul>
<li>A ping-pong mechanism was implemented to measure round-trip message latency.</li>
<li>Metrics were collected for a sample size of <b>1000 messages</b>.</li>
</ul>
<h4><a class="anchor" id="autotoc_md39"></a>
Order Placement Latency:</h4>
<ul>
<li>Timestamps were recorded before sending an order and after receiving a response from the Deribit API.</li>
<li>Metrics were collected for a sample size of <b>1000 orders</b>.</li>
</ul>
<h4><a class="anchor" id="autotoc_md40"></a>
Market Data Processing Latency:</h4>
<ul>
<li>Timestamps were recorded before and after processing market data messages.</li>
<li>Metrics were collected for a sample size of <b>1000 messages</b>.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md42"></a>
2. Before/After Performance Metrics</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Metric   </th><th class="markdownTableHeadNone">Before Optimization   </th><th class="markdownTableHeadNone">After Optimization    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>WebSocket Propagation Latency (ms)</b>   </td><td class="markdownTableBodyNone">Avg: ~0.50, Max: ~1.20   </td><td class="markdownTableBodyNone">Avg: 0.35, Max: 0.79    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Order Placement Latency (ns)</b>   </td><td class="markdownTableBodyNone">Avg: ~200M, Max: ~250M   </td><td class="markdownTableBodyNone">Avg: 170M, Max: 181M    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Market Data Processing (ns)</b>   </td><td class="markdownTableBodyNone">Avg: ~12K, Max: ~150K   </td><td class="markdownTableBodyNone">Avg: 8.58K, Max: ~97K   </td></tr>
</table>
<hr  />
<h2><a class="anchor" id="autotoc_md44"></a>
Observations</h2>
<h3><a class="anchor" id="autotoc_md45"></a>
WebSocket Propagation Latency:</h3>
<ul>
<li><b>Improvement</b>: Reduced from an average of ~0.50 ms to <b>0.35 ms</b>, with the maximum latency reduced from ~1.20 ms to <b>0.79 ms</b>.</li>
<li><b>Cause of Improvement</b>:<ul>
<li>Disabled WebSocket auto-fragmentation (<code>ws_.auto_fragment(false)</code>).</li>
<li>Enabled <code>TCP_NODELAY</code> to disable Nagle's algorithm and send small packets immediately.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md46"></a>
Order Placement Latency:</h3>
<ul>
<li><b>Improvement</b>: Reduced from an average of ~200 ms to <b>170 ms</b>, with the maximum latency reduced from ~250 ms to <b>181 ms</b>.</li>
<li><b>Cause of Improvement</b>:<ul>
<li>Optimized JSON serialization/deserialization using <code>simdjson</code>.</li>
<li>Efficient queuing with <code>moodycamel::ConcurrentQueue</code> for outgoing messages.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md47"></a>
Market Data Processing Latency:</h3>
<ul>
<li><b>Improvement</b>: Reduced from an average of ~12 Âµs to <b>8.58 Âµs</b>, with the maximum latency reduced from ~150 Âµs to <b>97 Âµs</b>.</li>
<li><b>Cause of Improvement</b>:<ul>
<li>Reused buffers via a custom object pool to avoid frequent memory allocation/deallocation.</li>
<li>Optimized JSON parsing with <code>simdjson</code>.</li>
</ul>
</li>
</ul>
<hr  />
 </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
